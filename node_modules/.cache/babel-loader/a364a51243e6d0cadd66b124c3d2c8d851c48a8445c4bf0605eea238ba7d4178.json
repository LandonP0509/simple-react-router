{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"useMergedRef\", {\n  enumerable: true,\n  get: function () {\n    return useMergedRef;\n  }\n});\nconst _react = require(\"react\");\nfunction useMergedRef(refA, refB) {\n  const cleanupA = (0, _react.useRef)(() => {});\n  const cleanupB = (0, _react.useRef)(() => {});\n  return (0, _react.useMemo)(() => {\n    if (!refA || !refB) {\n      return refA || refB;\n    }\n    return current => {\n      if (current === null) {\n        cleanupA.current();\n        cleanupB.current();\n      } else {\n        cleanupA.current = applyRef(refA, current);\n        cleanupB.current = applyRef(refB, current);\n      }\n    };\n  }, [refA, refB]);\n}\nfunction applyRef(refA, current) {\n  if (typeof refA === 'function') {\n    const cleanup = refA(current);\n    if (typeof cleanup === 'function') {\n      return cleanup;\n    } else {\n      return () => refA(null);\n    }\n  } else {\n    refA.current = current;\n    return () => {\n      refA.current = null;\n    };\n  }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', {\n    value: true\n  });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}","map":{"version":3,"names":["useMergedRef","refA","refB","cleanupA","_react","useRef","cleanupB","useMemo","current","applyRef","cleanup"],"sources":["/Users/landonphillippi/node_modules/next/src/client/use-merged-ref.ts"],"sourcesContent":["import { useMemo, useRef, type Ref } from 'react'\n\n// This is a compatibility hook to support React 18 and 19 refs.\n// In 19, a cleanup function from refs may be returned.\n// In 18, returning a cleanup function creates a warning.\n// Since we take userspace refs, we don't know ahead of time if a cleanup function will be returned.\n// This implements cleanup functions with the old behavior in 18.\n// We know refs are always called alternating with `null` and then `T`.\n// So a call with `null` means we need to call the previous cleanup functions.\nexport function useMergedRef<TElement>(\n  refA: Ref<TElement>,\n  refB: Ref<TElement>\n): Ref<TElement> {\n  const cleanupA = useRef<() => void>(() => {})\n  const cleanupB = useRef<() => void>(() => {})\n\n  return useMemo(() => {\n    if (!refA || !refB) {\n      return refA || refB\n    }\n\n    return (current: TElement | null): void => {\n      if (current === null) {\n        cleanupA.current()\n        cleanupB.current()\n      } else {\n        cleanupA.current = applyRef(refA, current)\n        cleanupB.current = applyRef(refB, current)\n      }\n    }\n  }, [refA, refB])\n}\n\nfunction applyRef<TElement>(\n  refA: NonNullable<Ref<TElement>>,\n  current: TElement\n) {\n  if (typeof refA === 'function') {\n    const cleanup = refA(current)\n    if (typeof cleanup === 'function') {\n      return cleanup\n    } else {\n      return () => refA(null)\n    }\n  } else {\n    refA.current = current\n    return () => {\n      refA.current = null\n    }\n  }\n}\n"],"mappings":";;;;;+BASgB;;;WAAAA,YAAA;;;uBAT0B;AASnC,SAASA,aACdC,IAAmB,EACnBC,IAAmB;EAEnB,MAAMC,QAAA,GAAW,IAAAC,MAAA,CAAAC,MAAM,EAAa,OAAO;EAC3C,MAAMC,QAAA,GAAW,IAAAF,MAAA,CAAAC,MAAM,EAAa,OAAO;EAE3C,OAAO,IAAAD,MAAA,CAAAG,OAAO,EAAC;IACb,IAAI,CAACN,IAAA,IAAQ,CAACC,IAAA,EAAM;MAClB,OAAOD,IAAA,IAAQC,IAAA;IACjB;IAEA,OAAQM,OAAA;MACN,IAAIA,OAAA,KAAY,MAAM;QACpBL,QAAA,CAASK,OAAO;QAChBF,QAAA,CAASE,OAAO;MAClB,OAAO;QACLL,QAAA,CAASK,OAAO,GAAGC,QAAA,CAASR,IAAA,EAAMO,OAAA;QAClCF,QAAA,CAASE,OAAO,GAAGC,QAAA,CAASP,IAAA,EAAMM,OAAA;MACpC;IACF;EACF,GAAG,CAACP,IAAA,EAAMC,IAAA,CAAK;AACjB;AAEA,SAASO,SACPR,IAAgC,EAChCO,OAAiB;EAEjB,IAAI,OAAOP,IAAA,KAAS,YAAY;IAC9B,MAAMS,OAAA,GAAUT,IAAA,CAAKO,OAAA;IACrB,IAAI,OAAOE,OAAA,KAAY,YAAY;MACjC,OAAOA,OAAA;IACT,OAAO;MACL,OAAO,MAAMT,IAAA,CAAK;IACpB;EACF,OAAO;IACLA,IAAA,CAAKO,OAAO,GAAGA,OAAA;IACf,OAAO;MACLP,IAAA,CAAKO,OAAO,GAAG;IACjB;EACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}