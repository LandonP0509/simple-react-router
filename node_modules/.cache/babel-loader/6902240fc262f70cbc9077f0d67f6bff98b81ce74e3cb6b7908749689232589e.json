{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  getNamedMiddlewareRegex: null,\n  getNamedRouteRegex: null,\n  getRouteRegex: null,\n  parseParameter: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  getNamedMiddlewareRegex: function () {\n    return getNamedMiddlewareRegex;\n  },\n  getNamedRouteRegex: function () {\n    return getNamedRouteRegex;\n  },\n  getRouteRegex: function () {\n    return getRouteRegex;\n  },\n  parseParameter: function () {\n    return parseParameter;\n  }\n});\nconst _constants = require(\"../../../../lib/constants\");\nconst _interceptionroutes = require(\"../../../../server/lib/interception-routes\");\nconst _escaperegexp = require(\"../../escape-regexp\");\nconst _removetrailingslash = require(\"./remove-trailing-slash\");\n/**\n * Regular expression pattern used to match route parameters.\n * Matches both single parameters and parameter groups.\n * Examples:\n *   - `[[...slug]]` matches parameter group with key 'slug', repeat: true, optional: true\n *   - `[...slug]` matches parameter group with key 'slug', repeat: true, optional: false\n *   - `[[foo]]` matches parameter with key 'foo', repeat: false, optional: true\n *   - `[bar]` matches parameter with key 'bar', repeat: false, optional: false\n */\nconst PARAMETER_PATTERN = /\\[((?:\\[.*\\])|.+)\\]/;\nfunction parseParameter(param) {\n  const match = param.match(PARAMETER_PATTERN);\n  if (!match) {\n    return parseMatchedParameter(param);\n  }\n  return parseMatchedParameter(match[1]);\n}\n/**\n * Parses a matched parameter from the PARAMETER_PATTERN regex to a data structure that can be used\n * to generate the parametrized route.\n * Examples:\n *   - `[...slug]` -> `{ key: 'slug', repeat: true, optional: true }`\n *   - `...slug` -> `{ key: 'slug', repeat: true, optional: false }`\n *   - `[foo]` -> `{ key: 'foo', repeat: false, optional: true }`\n *   - `bar` -> `{ key: 'bar', repeat: false, optional: false }`\n * @param param - The matched parameter to parse.\n * @returns The parsed parameter as a data structure.\n */\nfunction parseMatchedParameter(param) {\n  const optional = param.startsWith('[') && param.endsWith(']');\n  if (optional) {\n    param = param.slice(1, -1);\n  }\n  const repeat = param.startsWith('...');\n  if (repeat) {\n    param = param.slice(3);\n  }\n  return {\n    key: param,\n    repeat,\n    optional\n  };\n}\nfunction getParametrizedRoute(route) {\n  const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split('/');\n  const groups = {};\n  let groupIndex = 1;\n  return {\n    parameterizedRoute: segments.map(segment => {\n      const markerMatch = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find(m => segment.startsWith(m));\n      const paramMatches = segment.match(PARAMETER_PATTERN) // Check for parameters\n      ;\n      if (markerMatch && paramMatches) {\n        const {\n          key,\n          optional,\n          repeat\n        } = parseMatchedParameter(paramMatches[1]);\n        groups[key] = {\n          pos: groupIndex++,\n          repeat,\n          optional\n        };\n        return \"/\" + (0, _escaperegexp.escapeStringRegexp)(markerMatch) + \"([^/]+?)\";\n      } else if (paramMatches) {\n        const {\n          key,\n          repeat,\n          optional\n        } = parseMatchedParameter(paramMatches[1]);\n        groups[key] = {\n          pos: groupIndex++,\n          repeat,\n          optional\n        };\n        return repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';\n      } else {\n        return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n      }\n    }).join(''),\n    groups\n  };\n}\nfunction getRouteRegex(normalizedRoute) {\n  const {\n    parameterizedRoute,\n    groups\n  } = getParametrizedRoute(normalizedRoute);\n  return {\n    re: new RegExp(\"^\" + parameterizedRoute + \"(?:/)?$\"),\n    groups: groups\n  };\n}\n/**\n * Builds a function to generate a minimal routeKey using only a-z and minimal\n * number of characters.\n */\nfunction buildGetSafeRouteKey() {\n  let i = 0;\n  return () => {\n    let routeKey = '';\n    let j = ++i;\n    while (j > 0) {\n      routeKey += String.fromCharCode(97 + (j - 1) % 26);\n      j = Math.floor((j - 1) / 26);\n    }\n    return routeKey;\n  };\n}\nfunction getSafeKeyFromSegment(param) {\n  let {\n    interceptionMarker,\n    getSafeRouteKey,\n    segment,\n    routeKeys,\n    keyPrefix\n  } = param;\n  const {\n    key,\n    optional,\n    repeat\n  } = parseMatchedParameter(segment);\n  // replace any non-word characters since they can break\n  // the named regex\n  let cleanedKey = key.replace(/\\W/g, '');\n  if (keyPrefix) {\n    cleanedKey = \"\" + keyPrefix + cleanedKey;\n  }\n  let invalidKey = false;\n  // check if the key is still invalid and fallback to using a known\n  // safe key\n  if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n    invalidKey = true;\n  }\n  if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {\n    invalidKey = true;\n  }\n  if (invalidKey) {\n    cleanedKey = getSafeRouteKey();\n  }\n  if (keyPrefix) {\n    routeKeys[cleanedKey] = \"\" + keyPrefix + key;\n  } else {\n    routeKeys[cleanedKey] = key;\n  }\n  // if the segment has an interception marker, make sure that's part of the regex pattern\n  // this is to ensure that the route with the interception marker doesn't incorrectly match\n  // the non-intercepted route (ie /app/(.)[username] should not match /app/[username])\n  const interceptionPrefix = interceptionMarker ? (0, _escaperegexp.escapeStringRegexp)(interceptionMarker) : '';\n  return repeat ? optional ? \"(?:/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">.+?))?\" : \"/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">.+?)\" : \"/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">[^/]+?)\";\n}\nfunction getNamedParametrizedRoute(route, prefixRouteKeys) {\n  const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split('/');\n  const getSafeRouteKey = buildGetSafeRouteKey();\n  const routeKeys = {};\n  return {\n    namedParameterizedRoute: segments.map(segment => {\n      const hasInterceptionMarker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some(m => segment.startsWith(m));\n      const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n      ;\n      if (hasInterceptionMarker && paramMatches) {\n        const [usedMarker] = segment.split(paramMatches[0]);\n        return getSafeKeyFromSegment({\n          getSafeRouteKey,\n          interceptionMarker: usedMarker,\n          segment: paramMatches[1],\n          routeKeys,\n          keyPrefix: prefixRouteKeys ? _constants.NEXT_INTERCEPTION_MARKER_PREFIX : undefined\n        });\n      } else if (paramMatches) {\n        return getSafeKeyFromSegment({\n          getSafeRouteKey,\n          segment: paramMatches[1],\n          routeKeys,\n          keyPrefix: prefixRouteKeys ? _constants.NEXT_QUERY_PARAM_PREFIX : undefined\n        });\n      } else {\n        return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n      }\n    }).join(''),\n    routeKeys\n  };\n}\nfunction getNamedRouteRegex(normalizedRoute, prefixRouteKey) {\n  const result = getNamedParametrizedRoute(normalizedRoute, prefixRouteKey);\n  return {\n    ...getRouteRegex(normalizedRoute),\n    namedRegex: \"^\" + result.namedParameterizedRoute + \"(?:/)?$\",\n    routeKeys: result.routeKeys\n  };\n}\nfunction getNamedMiddlewareRegex(normalizedRoute, options) {\n  const {\n    parameterizedRoute\n  } = getParametrizedRoute(normalizedRoute);\n  const {\n    catchAll = true\n  } = options;\n  if (parameterizedRoute === '/') {\n    let catchAllRegex = catchAll ? '.*' : '';\n    return {\n      namedRegex: \"^/\" + catchAllRegex + \"$\"\n    };\n  }\n  const {\n    namedParameterizedRoute\n  } = getNamedParametrizedRoute(normalizedRoute, false);\n  let catchAllGroupedRegex = catchAll ? '(?:(/.*)?)' : '';\n  return {\n    namedRegex: \"^\" + namedParameterizedRoute + catchAllGroupedRegex + \"$\"\n  };\n}","map":{"version":3,"names":["getNamedMiddlewareRegex","getNamedRouteRegex","getRouteRegex","parseParameter","PARAMETER_PATTERN","param","match","parseMatchedParameter","optional","startsWith","endsWith","slice","repeat","key","getParametrizedRoute","route","segments","_removetrailingslash","removeTrailingSlash","split","groups","groupIndex","parameterizedRoute","map","segment","markerMatch","_interceptionroutes","INTERCEPTION_ROUTE_MARKERS","find","m","paramMatches","pos","_escaperegexp","escapeStringRegexp","join","normalizedRoute","re","RegExp","buildGetSafeRouteKey","i","routeKey","j","String","fromCharCode","Math","floor","getSafeKeyFromSegment","interceptionMarker","getSafeRouteKey","routeKeys","keyPrefix","cleanedKey","replace","invalidKey","length","isNaN","parseInt","interceptionPrefix","getNamedParametrizedRoute","prefixRouteKeys","namedParameterizedRoute","hasInterceptionMarker","some","usedMarker","_constants","NEXT_INTERCEPTION_MARKER_PREFIX","undefined","NEXT_QUERY_PARAM_PREFIX","prefixRouteKey","result","namedRegex","options","catchAll","catchAllRegex","catchAllGroupedRegex"],"sources":["/Users/landonphillippi/node_modules/next/src/shared/lib/router/utils/route-regex.ts"],"sourcesContent":["import {\n  NEXT_INTERCEPTION_MARKER_PREFIX,\n  NEXT_QUERY_PARAM_PREFIX,\n} from '../../../../lib/constants'\nimport { INTERCEPTION_ROUTE_MARKERS } from '../../../../server/lib/interception-routes'\nimport { escapeStringRegexp } from '../../escape-regexp'\nimport { removeTrailingSlash } from './remove-trailing-slash'\n\nexport interface Group {\n  pos: number\n  repeat: boolean\n  optional: boolean\n}\n\nexport interface RouteRegex {\n  groups: { [groupName: string]: Group }\n  re: RegExp\n}\n\n/**\n * Regular expression pattern used to match route parameters.\n * Matches both single parameters and parameter groups.\n * Examples:\n *   - `[[...slug]]` matches parameter group with key 'slug', repeat: true, optional: true\n *   - `[...slug]` matches parameter group with key 'slug', repeat: true, optional: false\n *   - `[[foo]]` matches parameter with key 'foo', repeat: false, optional: true\n *   - `[bar]` matches parameter with key 'bar', repeat: false, optional: false\n */\nconst PARAMETER_PATTERN = /\\[((?:\\[.*\\])|.+)\\]/\n\n/**\n * Parses a given parameter from a route to a data structure that can be used\n * to generate the parametrized route.\n * Examples:\n *   - `[[...slug]]` -> `{ key: 'slug', repeat: true, optional: true }`\n *   - `[...slug]` -> `{ key: 'slug', repeat: true, optional: false }`\n *   - `[[foo]]` -> `{ key: 'foo', repeat: false, optional: true }`\n *   - `[bar]` -> `{ key: 'bar', repeat: false, optional: false }`\n *   - `fizz` -> `{ key: 'fizz', repeat: false, optional: false }`\n * @param param - The parameter to parse.\n * @returns The parsed parameter as a data structure.\n */\nexport function parseParameter(param: string) {\n  const match = param.match(PARAMETER_PATTERN)\n\n  if (!match) {\n    return parseMatchedParameter(param)\n  }\n\n  return parseMatchedParameter(match[1])\n}\n\n/**\n * Parses a matched parameter from the PARAMETER_PATTERN regex to a data structure that can be used\n * to generate the parametrized route.\n * Examples:\n *   - `[...slug]` -> `{ key: 'slug', repeat: true, optional: true }`\n *   - `...slug` -> `{ key: 'slug', repeat: true, optional: false }`\n *   - `[foo]` -> `{ key: 'foo', repeat: false, optional: true }`\n *   - `bar` -> `{ key: 'bar', repeat: false, optional: false }`\n * @param param - The matched parameter to parse.\n * @returns The parsed parameter as a data structure.\n */\nfunction parseMatchedParameter(param: string) {\n  const optional = param.startsWith('[') && param.endsWith(']')\n  if (optional) {\n    param = param.slice(1, -1)\n  }\n  const repeat = param.startsWith('...')\n  if (repeat) {\n    param = param.slice(3)\n  }\n  return { key: param, repeat, optional }\n}\n\nfunction getParametrizedRoute(route: string) {\n  const segments = removeTrailingSlash(route).slice(1).split('/')\n  const groups: { [groupName: string]: Group } = {}\n  let groupIndex = 1\n  return {\n    parameterizedRoute: segments\n      .map((segment) => {\n        const markerMatch = INTERCEPTION_ROUTE_MARKERS.find((m) =>\n          segment.startsWith(m)\n        )\n        const paramMatches = segment.match(PARAMETER_PATTERN) // Check for parameters\n\n        if (markerMatch && paramMatches) {\n          const { key, optional, repeat } = parseMatchedParameter(\n            paramMatches[1]\n          )\n          groups[key] = { pos: groupIndex++, repeat, optional }\n          return `/${escapeStringRegexp(markerMatch)}([^/]+?)`\n        } else if (paramMatches) {\n          const { key, repeat, optional } = parseMatchedParameter(\n            paramMatches[1]\n          )\n          groups[key] = { pos: groupIndex++, repeat, optional }\n          return repeat ? (optional ? '(?:/(.+?))?' : '/(.+?)') : '/([^/]+?)'\n        } else {\n          return `/${escapeStringRegexp(segment)}`\n        }\n      })\n      .join(''),\n    groups,\n  }\n}\n\n/**\n * From a normalized route this function generates a regular expression and\n * a corresponding groups object intended to be used to store matching groups\n * from the regular expression.\n */\nexport function getRouteRegex(normalizedRoute: string): RouteRegex {\n  const { parameterizedRoute, groups } = getParametrizedRoute(normalizedRoute)\n  return {\n    re: new RegExp(`^${parameterizedRoute}(?:/)?$`),\n    groups: groups,\n  }\n}\n\n/**\n * Builds a function to generate a minimal routeKey using only a-z and minimal\n * number of characters.\n */\nfunction buildGetSafeRouteKey() {\n  let i = 0\n\n  return () => {\n    let routeKey = ''\n    let j = ++i\n    while (j > 0) {\n      routeKey += String.fromCharCode(97 + ((j - 1) % 26))\n      j = Math.floor((j - 1) / 26)\n    }\n    return routeKey\n  }\n}\n\nfunction getSafeKeyFromSegment({\n  interceptionMarker,\n  getSafeRouteKey,\n  segment,\n  routeKeys,\n  keyPrefix,\n}: {\n  interceptionMarker?: string\n  getSafeRouteKey: () => string\n  segment: string\n  routeKeys: Record<string, string>\n  keyPrefix?: string\n}) {\n  const { key, optional, repeat } = parseMatchedParameter(segment)\n\n  // replace any non-word characters since they can break\n  // the named regex\n  let cleanedKey = key.replace(/\\W/g, '')\n\n  if (keyPrefix) {\n    cleanedKey = `${keyPrefix}${cleanedKey}`\n  }\n  let invalidKey = false\n\n  // check if the key is still invalid and fallback to using a known\n  // safe key\n  if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n    invalidKey = true\n  }\n  if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {\n    invalidKey = true\n  }\n\n  if (invalidKey) {\n    cleanedKey = getSafeRouteKey()\n  }\n\n  if (keyPrefix) {\n    routeKeys[cleanedKey] = `${keyPrefix}${key}`\n  } else {\n    routeKeys[cleanedKey] = key\n  }\n\n  // if the segment has an interception marker, make sure that's part of the regex pattern\n  // this is to ensure that the route with the interception marker doesn't incorrectly match\n  // the non-intercepted route (ie /app/(.)[username] should not match /app/[username])\n  const interceptionPrefix = interceptionMarker\n    ? escapeStringRegexp(interceptionMarker)\n    : ''\n\n  return repeat\n    ? optional\n      ? `(?:/${interceptionPrefix}(?<${cleanedKey}>.+?))?`\n      : `/${interceptionPrefix}(?<${cleanedKey}>.+?)`\n    : `/${interceptionPrefix}(?<${cleanedKey}>[^/]+?)`\n}\n\nfunction getNamedParametrizedRoute(route: string, prefixRouteKeys: boolean) {\n  const segments = removeTrailingSlash(route).slice(1).split('/')\n  const getSafeRouteKey = buildGetSafeRouteKey()\n  const routeKeys: { [named: string]: string } = {}\n  return {\n    namedParameterizedRoute: segments\n      .map((segment) => {\n        const hasInterceptionMarker = INTERCEPTION_ROUTE_MARKERS.some((m) =>\n          segment.startsWith(m)\n        )\n        const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n\n        if (hasInterceptionMarker && paramMatches) {\n          const [usedMarker] = segment.split(paramMatches[0])\n\n          return getSafeKeyFromSegment({\n            getSafeRouteKey,\n            interceptionMarker: usedMarker,\n            segment: paramMatches[1],\n            routeKeys,\n            keyPrefix: prefixRouteKeys\n              ? NEXT_INTERCEPTION_MARKER_PREFIX\n              : undefined,\n          })\n        } else if (paramMatches) {\n          return getSafeKeyFromSegment({\n            getSafeRouteKey,\n            segment: paramMatches[1],\n            routeKeys,\n            keyPrefix: prefixRouteKeys ? NEXT_QUERY_PARAM_PREFIX : undefined,\n          })\n        } else {\n          return `/${escapeStringRegexp(segment)}`\n        }\n      })\n      .join(''),\n    routeKeys,\n  }\n}\n\n/**\n * This function extends `getRouteRegex` generating also a named regexp where\n * each group is named along with a routeKeys object that indexes the assigned\n * named group with its corresponding key. When the routeKeys need to be\n * prefixed to uniquely identify internally the \"prefixRouteKey\" arg should\n * be \"true\" currently this is only the case when creating the routes-manifest\n * during the build\n */\nexport function getNamedRouteRegex(\n  normalizedRoute: string,\n  prefixRouteKey: boolean\n) {\n  const result = getNamedParametrizedRoute(normalizedRoute, prefixRouteKey)\n  return {\n    ...getRouteRegex(normalizedRoute),\n    namedRegex: `^${result.namedParameterizedRoute}(?:/)?$`,\n    routeKeys: result.routeKeys,\n  }\n}\n\n/**\n * Generates a named regexp.\n * This is intended to be using for build time only.\n */\nexport function getNamedMiddlewareRegex(\n  normalizedRoute: string,\n  options: {\n    catchAll?: boolean\n  }\n) {\n  const { parameterizedRoute } = getParametrizedRoute(normalizedRoute)\n  const { catchAll = true } = options\n  if (parameterizedRoute === '/') {\n    let catchAllRegex = catchAll ? '.*' : ''\n    return {\n      namedRegex: `^/${catchAllRegex}$`,\n    }\n  }\n\n  const { namedParameterizedRoute } = getNamedParametrizedRoute(\n    normalizedRoute,\n    false\n  )\n  let catchAllGroupedRegex = catchAll ? '(?:(/.*)?)' : ''\n  return {\n    namedRegex: `^${namedParameterizedRoute}${catchAllGroupedRegex}$`,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}