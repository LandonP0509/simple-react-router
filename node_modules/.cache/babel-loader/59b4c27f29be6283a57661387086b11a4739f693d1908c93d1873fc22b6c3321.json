{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"default\", {\n  enumerable: true,\n  get: function () {\n    return SideEffect;\n  }\n});\nconst _react = require(\"react\");\nconst isServer = typeof window === 'undefined';\nconst useClientOnlyLayoutEffect = isServer ? () => {} : _react.useLayoutEffect;\nconst useClientOnlyEffect = isServer ? () => {} : _react.useEffect;\nfunction SideEffect(props) {\n  const {\n    headManager,\n    reduceComponentsToState\n  } = props;\n  function emitChange() {\n    if (headManager && headManager.mountedInstances) {\n      const headElements = _react.Children.toArray(Array.from(headManager.mountedInstances).filter(Boolean));\n      headManager.updateHead(reduceComponentsToState(headElements, props));\n    }\n  }\n  if (isServer) {\n    var _headManager_mountedInstances;\n    headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n    emitChange();\n  }\n  useClientOnlyLayoutEffect(() => {\n    var _headManager_mountedInstances;\n    headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n    return () => {\n      var _headManager_mountedInstances;\n      headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.delete(props.children);\n    };\n  });\n  // We need to call `updateHead` method whenever the `SideEffect` is trigger in all\n  // life-cycles: mount, update, unmount. However, if there are multiple `SideEffect`s\n  // being rendered, we only trigger the method from the last one.\n  // This is ensured by keeping the last unflushed `updateHead` in the `_pendingUpdate`\n  // singleton in the layout effect pass, and actually trigger it in the effect pass.\n  useClientOnlyLayoutEffect(() => {\n    if (headManager) {\n      headManager._pendingUpdate = emitChange;\n    }\n    return () => {\n      if (headManager) {\n        headManager._pendingUpdate = emitChange;\n      }\n    };\n  });\n  useClientOnlyEffect(() => {\n    if (headManager && headManager._pendingUpdate) {\n      headManager._pendingUpdate();\n      headManager._pendingUpdate = null;\n    }\n    return () => {\n      if (headManager && headManager._pendingUpdate) {\n        headManager._pendingUpdate();\n        headManager._pendingUpdate = null;\n      }\n    };\n  });\n  return null;\n}","map":{"version":3,"names":["SideEffect","isServer","window","useClientOnlyLayoutEffect","_react","useLayoutEffect","useClientOnlyEffect","useEffect","props","headManager","reduceComponentsToState","emitChange","mountedInstances","headElements","Children","toArray","Array","from","filter","Boolean","updateHead","_headManager_mountedInstances","add","children","delete","_pendingUpdate"],"sources":["/Users/landonphillippi/node_modules/next/src/shared/lib/side-effect.tsx"],"sourcesContent":["import type React from 'react'\nimport { Children, useEffect, useLayoutEffect, type JSX } from 'react'\n\ntype State = JSX.Element[] | undefined\n\nexport type SideEffectProps = {\n  reduceComponentsToState: <T extends {}>(\n    components: Array<React.ReactElement<any>>,\n    props: T\n  ) => State\n  handleStateChange?: (state: State) => void\n  headManager: any\n  inAmpMode?: boolean\n  children: React.ReactNode\n}\n\nconst isServer = typeof window === 'undefined'\nconst useClientOnlyLayoutEffect = isServer ? () => {} : useLayoutEffect\nconst useClientOnlyEffect = isServer ? () => {} : useEffect\n\nexport default function SideEffect(props: SideEffectProps) {\n  const { headManager, reduceComponentsToState } = props\n\n  function emitChange() {\n    if (headManager && headManager.mountedInstances) {\n      const headElements = Children.toArray(\n        Array.from(headManager.mountedInstances as Set<React.ReactNode>).filter(\n          Boolean\n        )\n      ) as React.ReactElement[]\n      headManager.updateHead(reduceComponentsToState(headElements, props))\n    }\n  }\n\n  if (isServer) {\n    headManager?.mountedInstances?.add(props.children)\n    emitChange()\n  }\n\n  useClientOnlyLayoutEffect(() => {\n    headManager?.mountedInstances?.add(props.children)\n    return () => {\n      headManager?.mountedInstances?.delete(props.children)\n    }\n  })\n\n  // We need to call `updateHead` method whenever the `SideEffect` is trigger in all\n  // life-cycles: mount, update, unmount. However, if there are multiple `SideEffect`s\n  // being rendered, we only trigger the method from the last one.\n  // This is ensured by keeping the last unflushed `updateHead` in the `_pendingUpdate`\n  // singleton in the layout effect pass, and actually trigger it in the effect pass.\n  useClientOnlyLayoutEffect(() => {\n    if (headManager) {\n      headManager._pendingUpdate = emitChange\n    }\n    return () => {\n      if (headManager) {\n        headManager._pendingUpdate = emitChange\n      }\n    }\n  })\n\n  useClientOnlyEffect(() => {\n    if (headManager && headManager._pendingUpdate) {\n      headManager._pendingUpdate()\n      headManager._pendingUpdate = null\n    }\n    return () => {\n      if (headManager && headManager._pendingUpdate) {\n        headManager._pendingUpdate()\n        headManager._pendingUpdate = null\n      }\n    }\n  })\n\n  return null\n}\n"],"mappings":";;;;;+BAoBA;;;WAAwBA,UAAA;;;uBAnBuC;AAe/D,MAAMC,QAAA,GAAW,OAAOC,MAAA,KAAW;AACnC,MAAMC,yBAAA,GAA4BF,QAAA,GAAW,OAAO,IAAIG,MAAA,CAAAC,eAAe;AACvE,MAAMC,mBAAA,GAAsBL,QAAA,GAAW,OAAO,IAAIG,MAAA,CAAAG,SAAS;AAE5C,SAASP,WAAWQ,KAAsB;EACvD,MAAM;IAAEC,WAAW;IAAEC;EAAuB,CAAE,GAAGF,KAAA;EAEjD,SAASG,WAAA;IACP,IAAIF,WAAA,IAAeA,WAAA,CAAYG,gBAAgB,EAAE;MAC/C,MAAMC,YAAA,GAAeT,MAAA,CAAAU,QAAQ,CAACC,OAAO,CACnCC,KAAA,CAAMC,IAAI,CAACR,WAAA,CAAYG,gBAAgB,EAA0BM,MAAM,CACrEC,OAAA;MAGJV,WAAA,CAAYW,UAAU,CAACV,uBAAA,CAAwBG,YAAA,EAAcL,KAAA;IAC/D;EACF;EAEA,IAAIP,QAAA,EAAU;QACZoB,6BAAA;IAAAZ,WAAA,qBAAAY,6BAAA,GAAAZ,WAAA,CAAaG,gBAAgB,qBAA7BS,6BAAA,CAA+BC,GAAG,CAACd,KAAA,CAAMe,QAAQ;IACjDZ,UAAA;EACF;EAEAR,yBAAA,CAA0B;QACxBkB,6BAAA;IAAAZ,WAAA,qBAAAY,6BAAA,GAAAZ,WAAA,CAAaG,gBAAgB,qBAA7BS,6BAAA,CAA+BC,GAAG,CAACd,KAAA,CAAMe,QAAQ;IACjD,OAAO;UACLF,6BAAA;MAAAZ,WAAA,qBAAAY,6BAAA,GAAAZ,WAAA,CAAaG,gBAAgB,qBAA7BS,6BAAA,CAA+BG,MAAM,CAAChB,KAAA,CAAMe,QAAQ;IACtD;EACF;EAEA;EACA;EACA;EACA;EACA;EACApB,yBAAA,CAA0B;IACxB,IAAIM,WAAA,EAAa;MACfA,WAAA,CAAYgB,cAAc,GAAGd,UAAA;IAC/B;IACA,OAAO;MACL,IAAIF,WAAA,EAAa;QACfA,WAAA,CAAYgB,cAAc,GAAGd,UAAA;MAC/B;IACF;EACF;EAEAL,mBAAA,CAAoB;IAClB,IAAIG,WAAA,IAAeA,WAAA,CAAYgB,cAAc,EAAE;MAC7ChB,WAAA,CAAYgB,cAAc;MAC1BhB,WAAA,CAAYgB,cAAc,GAAG;IAC/B;IACA,OAAO;MACL,IAAIhB,WAAA,IAAeA,WAAA,CAAYgB,cAAc,EAAE;QAC7ChB,WAAA,CAAYgB,cAAc;QAC1BhB,WAAA,CAAYgB,cAAc,GAAG;MAC/B;IACF;EACF;EAEA,OAAO;AACT","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}